# goit-algo-hw-09
У конспекті ми розглянули приклад про розбиття суми на монети. Маємо набір монет [50, 25, 10, 5, 2, 1]. Уявіть, що ви розробляєте систему для касового апарату, яка повинна визначити оптимальний спосіб видачі решти покупцеві.

Вам необхідно написати дві функції для касової системи, яка видає решту покупцеві:

Функція жадібного алгоритму find_coins_greedy. Ця функція повинна приймати суму, яку потрібно видати покупцеві, і повертати словник із кількістю монет кожного номіналу, що використовуються для формування цієї суми. Наприклад, для суми 113 це буде словник {50: 2, 10: 1, 2: 1, 1: 1}. Алгоритм повинен бути жадібним, тобто спочатку вибирати найбільш доступні номінали монет.
Функція динамічного програмування find_min_coins. Ця функція також повинна приймати суму для видачі решти, але використовувати метод динамічного програмування, щоб знайти мінімальну кількість монет, необхідних для формування цієї суми. Функція повинна повертати словник із номіналами монет та їх кількістю для досягнення заданої суми найефективнішим способом. Наприклад, для суми 113 це буде словник {1: 1, 2: 1, 10: 1, 50: 2}
Порівняйте ефективність жадібного алгоритму та алгоритму динамічного програмування, базуючись на часі їх виконання або О великому та звертаючи увагу на їхню продуктивність при великих сумах. Висвітліть, як вони справляються з великими сумами та чому один алгоритм може бути більш ефективним за інший у певних ситуаціях. Свої висновки додайте у файл readme.md домашнього завдання.

# Порівняння ефективності жадібного алгоритму та алгоритму динамічного програмування
Жадібний алгоритм (find_coins_greedy)
Часова складність: O(n), де n - кількість доступних номіналів монет.

Ефективність: Жадібний алгоритм працює дуже швидко і підходить для практичних випадків, коли набір номіналів монет дозволяє завжди знайти оптимальне рішення (наприклад, стандартні монети США або Європи). Для суми 113 алгоритм знайде набір {50: 2, 10: 1, 2: 1, 1: 1}.

Недоліки: Жадібний підхід не завжди знаходить оптимальне рішення для всіх можливих наборів монет. Наприклад, якщо додати монету номіналом 6 до набору, жадібний алгоритм може не знайти мінімальну кількість монет для деяких сум.

Алгоритм динамічного програмування (find_min_coins)
Часова складність: O(amount * n), де n - кількість доступних номіналів монет, а amount - сума, яку потрібно видати.

Ефективність: Алгоритм динамічного програмування гарантує знаходження оптимального рішення, тобто мінімальної кількості монет для будь-якого набору номіналів. Для суми 113 алгоритм знайде той самий набір {50: 2, 10: 1, 2: 1, 1: 1}.

Недоліки: Більш висока часова складність в порівнянні з жадібним алгоритмом робить цей підхід менш ефективним для дуже великих сум.

# Висновки
Жадібний алгоритм є дуже ефективним і швидким для стандартних наборів монет, де він завжди знаходить оптимальне рішення.
Алгоритм динамічного програмування гарантує знаходження мінімальної кількості монет для будь-якого набору номіналів, але його часова складність є вищою, що може вплинути на продуктивність при дуже великих сумах.
Обидва алгоритми мають свої переваги і недоліки, і вибір між ними залежить від конкретного випадку використання та набору доступних номіналів монет.